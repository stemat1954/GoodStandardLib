
1. UNIVERSAL  METHODS

Universal methods are special methods that can
can be called for any object.  They're intrinsic
to the language and have special status because
they evaluate the construction of an object rather
than it's value. In particular, universal methods
can be called for null objects without causing disruption.


general method
{
	is_null? [eval]()( bool );

	is_not_null? [eval]()( bool );

	use_typename [eval] = typename proxy [eval];   

	use_handle [eval] = handle proxy [eval];

	reuse [term];	 

	is<t>? [eval]()( bool );  runtime

	as<t> [eval]= <t> proxy [eval,upd];	-- runtime, may be void

	as_base<t> [eval] = <t> proxy [eval,upd,init]; -- verified at compile-time, special access declaration

	as_actual<t> [eval] = <t> proxy [init];  -- runtime, may be void
}


:as_base<t> is a "static" type translation that can
be verified at compile time.  It's used to resolve a
specific external sub-object when inheritance rules
would otherwise hide a base method, or when the 
programmer wants to call a base abstract method 
non-virtually, or when an external subobject needs
to be initialized or reused by a subtype method.
In the latter case, the result proxy increases access
to [init] if the lead object has [upd] access.
:as_base<t> can also be called to clarify intent
when the compiler would automatically deduce the
base translation.


A proxy has an internal double-link representation
that can generally point to two sub-objects. 

The primary link references a sub-object that corresponds
to the proxy's stated type and access.  When a proxy is 
used in an object context, the primary link is used to
access the object.

An auxiliary link references a sub-object that corresponds
to an original linkage.  Generally, it represents a 
sub-object that corresponds to a derived subtype of the
proxy's stated type. 

>>> Dynamic type translations preserve auxilary links and 
update primary links.

When the lead object is a direct (static) reference to
an object, both links are the same.  Proxies linked to
inputs may not reference whole objects.  Thus, dynamic
type translations can't be used to "see beyond" an input's 
stated type.

Note: In particular, this applies to selectors and 
accessors that may return result proxies linked to
inputs.  The result proxy may only see part of an object's
type hierarchy on return.






2. ENUMERATED TYPE DEFINITION


type enum_type from enumerated  
{{	
	This is a sample type definition typical of that
	generated by the Pragma translator from an enum type 
	defintion.  It utilizes an alpha\<expr>set to
	map token values into integer values.  
	
	Note:  The generated type definition for every enum
	type is source-identical except for the type name.
	However, each enum type needs it's own set to 
	provide the token set, which means that even
	though the definition is source identical, set
	references must resolve to different objects.  This
	is similar to a generic definition with type factors, 
	except here the factors are object references.

		
	An enum type's int value can be used to compare 
	relative order and other arithmetic relationships. 
	However, note that the enumerated value can change 
	if the definition order is changed, so any code 
	that depends on definition order also needs to be 
	reviewed.  

	Code that compares two enum types for equality and/or 
	evaluates them in a select instruction is safe.  That 
	is, new tokens can be added and reordered without
	affecting existing code because changes to the enum
	type definition will force recompilation.

}}
{
	general
	{
		begin ( expr vex )		-- literal 
		{
			ao:base<enumerated>:begin( index:lookup( vex ) );
			ao.expr:begin( vex );
		}

		begin ( enum_type other )	-- copy
		{
			ao:base<enumerated>:begin( other:as_int );
			ao.expr:begin( other.expr );
		}

		as_expr [const] = expr proxy [const] ~x
		{
			~x -> ao.expr;
		}

		equal? [const ] ( enum_type other )( bool )
		{
			ao:as_int:equal?( other:as_int )( @this\bool );
		}

		before? [const] ( enum_type other )( bool )
		{
			ao:as_int:before?( other:as_int )( @this\bool );
		}
	}

	common <expr>index index;  -- initialized internally

	instance
	{
		expr;
	}
}

