
1. UNIVERSAL  METHODS

Universal methods are special methods that can
can be called for any object.  They're intrinsic
to the language and have special status because
they evaluate the otherwise internal representation
of objects.  In particular, universal methods can be
called for null objects without causing disruption.

Note:  The compiler may reject certain calls if
it can determine that a runtime result will be moot.


general method
{
	null? [eval]()( bool );

	not_null? [eval]()( bool );

	typename [eval] = typename proxy [eval];   

	reuse [term];	 


	base<t> [eval] = <t> proxy [eval,upd,init];	-- special attribution for internal use 

	is<t>? [eval]()( bool );  

	as<t> [eval]= <t> proxy [eval,upd];	

	as_actual<t> [eval] = <t> proxy [init];
}


Generic methods are sub-object type translation methods.

:base<t> is a "static" translation that can be verified
at compile time.  It's used to resolve a typed base 
sub-object when inheritance rules would otherwise
hide a base type method, or when the programmer
wants to make intent clear.  In particular, :base<t>
is often used to call :begin for instance sub-objects,
and to call a particular base method in an adaptable
type hierarchy.

The other type translation methods are "dynamic" 
translation methods that only have pratical use
when the lead object is referenced by proxy.  
In effect, they are proxy conversion methods. 
When the lead object is a direct (static) reference
to an object, the dynamic translation methods revert
to static (base) translations that can be verified
and optimized.

A proxy has an internal double-link representation
that can generally point to two sub-objects. 

The primary link references a sub-object that corresponds
to the proxy's stated type and access.  When a proxy is 
used in an object context, the primary link is used to
access the object.

An auxiliary link references a sub-object that corresponds
to an original linkage.  Generally, it represents a 
sub-object that corresponds to a derived subtype of the
proxy's stated type. 

>>> Dynamic type translations preserve auxilary links and 
update primary links.

When the lead object is a direct (static) reference to
an object, both links are the same.  Proxies linked to
inputs may not reference whole objects.  Thus, dynamic
type translations can't be used to "see beyond" an input's 
stated type.

Note: In particular, this applies to selectors and 
accessors that may return result proxies linked to
inputs.  The result proxy may only see part of an object's
type hierarchy on return.






2. ENUMERATED TYPE DEFINITION


type enum_type from enumerated  
{{	
	This is a sample type definition typical of that
	generated by the Pragma translator from an enum type 
	defintion.  It utilizes an alpha\<expr>set to
	map token values into integer values.  
	
	Note:  The generated type definition for every enum
	type is source-identical except for the type name.
	However, each enum type needs it's own set to 
	provide the token set, which means that even
	though the definition is source identical, set
	references must resolve to different objects.  This
	is similar to a generic definition with type factors, 
	except here the factors are object references.

		
	An enum type's int value can be used to compare 
	relative order and other arithmetic relationships. 
	However, note that the enumerated value can change 
	if the definition order is changed, so any code 
	that depends on definition order also needs to be 
	reviewed.  

	Code that compares two enum types for equality and/or 
	evaluates them in a select instruction is safe.  That 
	is, new tokens can be added and reordered without
	affecting existing code because changes to the enum
	type definition will force recompilation.

}}
{
	general
	{
		begin ( expr vex )		-- literal 
		{
			ao:base<enumerated>:begin( index:lookup( vex ) );
			ao.expr:begin( vex );
		}

		begin ( enum_type other )	-- copy
		{
			ao:base<enumerated>:begin( other:as_int );
			ao.expr:begin( other.expr );
		}

		as_expr [const] = expr proxy [const] ~x
		{
			~x -> ao.expr;
		}

		equal? [const ] ( enum_type other )( bool )
		{
			ao:as_int:equal?( other:as_int )( @this\bool );
		}

		before? [const] ( enum_type other )( bool )
		{
			ao:as_int:before?( other:as_int )( @this\bool );
		}
	}

	common <expr>index index;  -- initialized internally

	instance
	{
		expr;
	}
}

