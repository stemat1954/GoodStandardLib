
1. UNIVERSAL  METHODS

Universal methods are special methods that can
can be called for any object.  They're intrinsic
to the language and have special status because
they evaluate the construction of an object rather
than it's value. In particular, universal methods
can be called for null objects without causing disruption.


general method
{
	is_null? [eval]()( bool );

	is_not_null? [eval]()( bool );

	use_typename [eval] = typename proxy [eval];   

	use_handle [eval] = handle proxy [eval];

	reuse [term];	 

	is<t>? [eval]()( bool );  runtime

	is_actual<t>? [eval]()( bool );

	as<t> [eval]= <t> proxy [eval,upd];	-- runtime, may be void

	as_actual<t> [eval] = <t> proxy [init];  -- runtime, may be void

	base<t> [eval] = <t> proxy [eval,upd,init]; -- verified at compile-time, special access declaration
}


:base<t> is a "static" type translation that can
be verified at compile time.  It's used to resolve a
specific external sub-object when inheritance rules
would otherwise hide a base method, or when the 
programmer wants to call a base abstract method 
non-virtually, or when an external subobject needs
to be initialized or reused by a subtype method.
In the latter case, the result proxy increases access
to [init] if the lead object has [upd] access.
:as_base<t> can also be called to clarify intent
when the compiler would automatically deduce the
base translation.


A proxy has an internal double-link representation
that can generally point to two sub-objects. 

The primary link references a sub-object that corresponds
to the proxy's stated type and access.  When a proxy is 
used in an object context, the primary link is used to
access the object.

An auxiliary link references a sub-object that corresponds
to an original linkage.  Generally, it represents a 
sub-object that corresponds to a derived subtype of the
proxy's stated type. 

>>> Dynamic type translations preserve auxilary links and 
update primary links.

When the lead object is a direct (static) reference to
an object, both links are the same.  Proxies linked to
inputs may not reference whole objects.  Thus, dynamic
type translations can't be used to "see beyond" an input's 
stated type.

Note: In particular, this applies to selectors and 
accessors that may return result proxies linked to
inputs.  The result proxy may only see part of an object's
type hierarchy on return.






2. ENUMERATED TYPE DEFINITION


type thing from enumerated
{{	
	This is a sample type definition typical of that
	generated by the Good translator from an enum type 
	defintion.  It utilizes an alpha\<expr>enumerator
	to map token values into integer values.  
	
	Note: The generated type definition for every enum
	type is source-identical except for the type name
	("thing" in this example).  However, each enum type 
	has it's own internal enumerator initialized for the
	enum type token set, so runtime results are unique 
	to the specifc type.

	An enum type's int value can be used to compare 
	relative order and other arithmetic relationships. 
	However, note that the enumerated value can change 
	if the definition order is changed, so any code 
	that depends on definition order also needs to be 
	reviewed.  

	Code that compares two enum types for equality and/or 
	evaluates them in a select instruction is safe.  That 
	is, new tokens can be added and reordered without
	affecting existing code because changes to the enum
	type definition will force recompilation.

}}
{
	general
	{
		begin ( expr token ) -- vex
		{
			io:base<enumerated>:begin( near\set:enumerate( token )( =int ) );
			io.token:begin( token );
		}

		begin ( thing other ) -- copy
		{
			io:base<enumerated>:begin( other:ordinal );
			io.token:begin( other.token );
		}

		token = expr proxy [eval] ~x
		{
			~x -> io.token;
		}

		is_before? ( thing other )( bool yes )
		{
			io:ordinal:is_before?( other:ordinal )( yes );
		}

		is_equal? ( thing other )( bool yes )
		{
			io:ordinal:is_equal?( other:ordinal )( yes );
		}
	}

	common <expr>enumerator set;  -- initialized internally

	instance
	{
		expr token;
	}
}

