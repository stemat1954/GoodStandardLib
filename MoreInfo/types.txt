
1. UNIVERSAL  METHODS

Universal methods are special methods that can
can be called for any object.  They're intrinsic
to the language and have special status because
they evaluate the construction of an object rather
than it's value. In particular, universal methods
can be called for null objects without causing disruption.

:use_addr can be used to uniquely identify and sort objects.

:reuse reconstructs an object without changing the
object's addr. A reused object has a null value.

-------

general method
{
	is_null? [eval]()( bool );

	is_not_null? [eval]()( bool );

	use_typename [eval] = typename proxy [eval];   

	use_addr [eval] = addr proxy [eval];

	is<t>? [eval]()( bool );  

	as<t> [eval] = <t> proxy [eval,upd];	-- may be void

	is_actual<t>? [eval]()( bool );

	as_actual<t> [eval] = <t> proxy [init];  -- may be void

	as_base<t> [eval] = <t> proxy [eval,upd,init]; -- verified at compile-time, reserved proxy permission syntax

	reuse [term];	 

}




2. ENUMERATED TYPE DEFINITION


enumm type foo ( 'a', 'b', 'c' )

type foo from enumerated
{{	
	This is a sample type definition typical of that
	generated by the Good translator from an enum type 
	defintion.  It utilizes an alpha\<expr>enumerator
	to map token values into integer values.  
	
	Note: The generated type definition for every enum
	type is source-identical except for the type name
	("foo" in this example).  However, each enum type 
	has it's own internal enumerator initialized for the
	enum type token set, so runtime results are unique 
	to the specifc type.

	Note: An enum type name can't be generi, so the
	type name can be used in lieu of an object name.

	An enum type's int value can be used to compare 
	relative order and other arithmetic relationships. 
	However, note that the enumerated value can change 
	if the definition order is changed, so any code 
	that depends on definition order also needs to be 
	reviewed.  

	Code that compares two enum types for equality and/or 
	evaluates them in a select instruction is safe.  That 
	is, new tokens can be added and reordered without
	affecting existing code because changes to the enum
	type definition will force recompilation.

}}
{
	general
	{
		begin ( expr ) -- vex
		{
			io:base<enumerated>:begin( near\mapping:enumerate( given\expr )( =int ) );
			io.expr:begin( given\expr );
		}

		begin ( foo ) -- copy
		{
			io:base<enumerated>:begin( given\foo:use_int );
			io.expr:begin( given\foo.expr );
		}

		use_expr = expr proxy [eval] ~x
		{
			~x -> io.expr;
		}

		is_before? ( foo )( bool )
		{
			io:use_int:is_before?( given\foo:use_int )( given\bool );
		}

		is_equal? ( foo )( bool )
		{
			io:use_int:is_equal?( given\foo:use_int )( given\bool );
		}
	}

	common <expr>enumerator mapping;  -- initialized internally

	instance
	{
		expr;
	}
}


