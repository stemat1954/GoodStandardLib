
page int in AlphaByGood



type int -- elementary, compatible, conventional
{{
	An int encapsulates the higest precision integer
	type supported by the runtime platform.

	See documentation for initial value expressions.

	[upd] methods that change value also have [eval] 
	functional equivalents that don't.

	These special value expressions are recognized:

		'min'
		'max'


	[upd] methods that have undefined results quit.

	[eval] methods that have undefined results return null
	outputs.

	An int is portable. See documentation for supported
	formats.

	Format notes...  

	Generic binary 'b' is supported for c compatability.

	Specific binary formats include 3 common encodings
	that differ in negative value representation (one's
	complement, two's complement, and sign/magnitude).

	Specific binary unicode formats UTF-8, UTF-16, and
	UTF-32 are also supported. For now, presume format 
	exprs are 'b:utf8', 'b:utf16', 'b:utf32'.  
			
	https://en.wikipedia.org/wiki/UTF-8
	https://en.wikipedia.org/wiki/UTF-16

	Specific binary 'b:ascii' writes a non-negative
	value as one byte and reads the same.

}}
{
	general 		
	{
		begin ( expr vex [opt] );				-- default '0'

		begin ( int other );					-- copy

		begin<#> ( word<<#>> w, expr fex );		-- word conversion

		
		begin ( mediator [upd], expr fex );		-- mediation

		store ( mediator [upd], expr fex );		-- ditto


		is_equal? ( int x )( bool );			-- equality
				
		is_before? ( int x )( bool );			-- ordinality ( same as is_less? )

		is_less? ( int x )( bool );				-- cardinality ( same as is_before? )

	
		set [upd]( int x );						-- intrinsic assign: io <= x 

		sgn [upd];								-- sign: io <= {-1,0,1}
		sgn [eval]()( int s );


		add [upd]( int x );						-- add:  io <= io + x 
		add [eval] ( int x )( int y );			

		sub [upd]( int x );						-- subtract: io <= io - x
		sub [eval] ( int x )( int y );

		mul [upd]( int x );						-- multiply: io <= io * x  
		mul [eval] ( int x )( int y );	

		div [upd]( int x );						-- divide: io <= io \ x (round-in)
		div [upd]( int x )( int r );			-- divide: io <= io \ x, r <= mod(io,x) 
		div [eval]( int x )( int y, int r );	-- divide: y <= io \ x, r <= mod(io,x)

		
		inc [upd];								-- increment: io <= io + 1 
		inc [eval]()( int y );	

		dec [upd];								-- decrement: io <= io - 1 
		dec [eval]()( int y );

		inf [upd];								-- inflate: io <= io + sgn(io) (to infinity)
		inf [eval]()( int y );

		def [upd];								-- deflate: io <= io - sgn(io) (to zero)
		def [eval]()( int y );

		neg [upd];								-- negate: io <= -io 
		neg [eval]()( int y );

		abs [upd];								-- absolute value:  io <= |io|
		abs [eval]()( int y );	

		dis [upd]( int x );						-- distance: io <= |(io - x)| (absolute diff)
		dis [eval]( int x )( int y );

		fma [upd]( int m, int b );				-- fused multiply add:  io <= m * io + b (linear transform)
		fma [eval]( int m, int b )( int y );

		mod [upd]( int x );						-- modulo: io <= residual of io \ x
		mod [eval]( int x )( int y );	

		exp [upd]( int x );						-- exponentiate: io <= io ^ x 
		exp [eval]( int x )( int y );

		log [upd]( int b );						-- log: io <= log base b of io
		log [eval]( int b )( int y );
	}
}









