
page int in AlphaByGood

enum type int_const ( 'min', 'max' );


type int -- elementary, compatible, conventional
{{
	An int encapsulates the higest precision integer
	type supported by the runtime platform.

	See documentation for initial value expressions.

	[upd] methods that change value also have [eval] 
	functional equivalents that don't.




	An int is portable. See documentation for supported
	formats.

	Format notes...  

	Generic binary 'b' is supported for c compatability.

	Specific binary formats include 3 common encodings
	that differ in negative value representation (one's
	complement, two's complement, and sign/magnitude).

	Specific binary unicode formats UTF-8, UTF-16, and
	UTF-32 are also supported. For now, presume format 
	exprs are 'b:utf8', 'b:utf16', 'b:utf32'.  
			
	https://en.wikipedia.org/wiki/UTF-8
	https://en.wikipedia.org/wiki/UTF-16

	Specific binary 'b:ascii' writes a non-negative
	value as one byte and reads the same.

}}
{
	general 		
	{
		begin ( expr vex [opt] );				-- digital expr, default '0'

		begin ( int_const vex );				-- enumerated const

		begin ( int other );					-- copy

		begin<#n> ( word<<#n>> w, expr fex );	 -- word conversion

		
		begin ( mediator [upd], expr fex );		-- mediation

		store ( mediator [upd], expr fex );		-- ditto


		is_equal? ( int n )( bool );			-- equality
				
		is_before? ( int n )( bool );			-- ordinality ( same as is_less? )

		is_less? ( int n )( bool );				-- cardinality ( same as is_before? )

	
		set [upd]( int n );						-- io <= n (intrinsic assign)

		add [upd]( int n );						-- io <= io + n  (add)
		add [eval] ( int n )( int x );			

		sub [upd]( int n );						-- io <= io - n  (subtract)
		sub [eval] ( int n )( int x );

		mul [upd]( int n );						-- io <= io * n  (multiply)
		mul [eval] ( int n )( int x );	

		div [upd]( int n );						-- io <= io \ n (divide and round-in)
		div [upd]( int n )( int r );			-- io <= io \ n, r <= mod(io,n) 
		div [eval]( int n )( int x, int r );	-- x <= io \ n, r <= mod(io,n)

		mod [upd]( int n );						-- io <= residual of io \ n (modulo)
		mod [eval]( int n )( int x );	

		pow [upd]( int n );						-- io <= io ^ n (power)
		pow [eval]( int n )( int x );

		fma [upd]( int m, int b );				-- io <= m * io + b (fused mul add, linear transform)
		fma [eval]( int m, int b )( int x );

		dis [upd]( int n );						-- io <= | io - n | (distance, absolute diff)
		dis [eval]( int n )( int x );

		neg [upd];								-- io <= -io  (negate)
		neg [eval]()( int x );

		abs [upd];								-- io <= |io| (absolute value)
		abs [eval]()( int x );	

		sgn [upd];								-- io <= (-1,0,1) (sign)
		sgn [eval]()( int x );

		inc [upd];								-- io <= io + 1 (increment)
		inc [eval]()( int x );	

		dec [upd];								-- io <= io - 1 (decrement)
		dec [eval]()( int x );

		inf [upd];								-- io <= io + sgn(io) (inflate)
		inf [eval]()( int x );

		def [upd];								-- io <= io - sgn(io) (deflate)
		def [eval]()( int x );
	}
}









