
page float in AlphaByGood

{{
	fp2 and fp10 are two distinct floating point types 
	with esentially the same api. 
	
	Note: fp2 and fp10 are NOT adhoc configurations of a 
	single generic type.

	fp2 is always supported by hardware and should be used
	for most purposes when decimal precision isn't required.
	
	fp10 is usually implemented in software and it should
	only be used in applications that need precise decimal
	fractions or powers of 10, such as financial and 
	accounting applications.

	These special values expressions are recognized:

		'min'
		'max'
		'epsilon'
		'+infinity'
		'-infinity'
		'nan' 

	
	See math.good for built-in functional subroutines
	for numeric types.

}}


type fp2 -- elementary, compatible, conventional
{{
	fp2 is a base-2 floating point number.  
	
	fp2 numbers can exactly represent any number that is
	a power of two, subject to inherent limits of exponent
	and fraction (mantissa).
}}
{

	general
	{
		begin ( expr vex [opt] );				-- digital expr, default = 0

		begin ( fp2 x );						-- copy

		begin ( fp10 x );						-- fp10 conversion

		begin ( int n );						-- int conversion

		begin<#n> ( word<<#n>> w, expr fex );	-- word conversion


		begin ( mediator [upd], expr fex );		-- mediation

		store ( mediator [upd], expr fex );		-- mediation


		is_equal? ( fp2 x )( bool );			-- equality
		
		is_before? ( fp2 x )( bool );			-- ordinality

		is_less? ( fp2 x )( bool );				-- cardinality


		is_precise? ( fp2 x )( bool );			-- io/x not fractional?

		
		set [upd]( fp2 x );						-- intrinsic assign: io <= x 

		to_int [eval]()( int n );				-- int conversion: n <= io (truncate fraction)

		sgn [eval]()( int s );					-- sign:  s <= {-1,0,1}


		add [upd]( fp2 x );						-- add: io <= io + x 
		add [eval]( fp2 x )( fp2 y );	

		sub [upd]( fp2 x );						-- subtract: io <= io - x 
		sub [eval]( fp2 x )( fp2 y );

		mul [upd]( fp2 x );						-- multiply: io <= io * x
		mul [eval]( fp2 x )( fp2 y );		

		div [upd]( fp2 x );						-- divide: io <= io / x 
		div [eval]( fp2 x )( fp2 y );

	
		neg [upd];								-- negate: io <= -io 
		neg [eval]()( fp2 y );

		abs [upd];								-- abs value: io <= |io|
		abs [eval]()( fp2 y );

		fma [upd]( fp2 m, fp2 b );				-- fused mul add: io <= ( m * io ) + b  (linear transform) 
		fma [eval]( fp2 m, fp2 b )( fp2 y );

		dis [upd]( fp2 x );						-- distance: io <= |(io - x)| (absolute diff)
		dis [eval]( fp2 x )( fp2 y );

		scl [upd]( int n );						-- scale: io <= io * ( 2 ^ n ) (exponent shift)
		scl [eval]( int n )( fp2 y );

		exp [upd]( int n, int d );				-- exponentiate: io <= io ^ (n/d) (rational) 
		exp [eval]( int n, int d )( fp2 y );

		exp [upd]( fp2 x );						-- exponentiate io <= io ^ x (real)
		exp [eval]( fp2 x )( fp2 y );

		log [upd]( fp2 b );						-- log: io <= log base b ( io )
		log [eval]( fp2 b )( fp2 y );


		rpu [upd]( fp2 x [opt] );				-- round to precision up: io <= io/x snap up/more (default = 1.0)
		rpu [eval]( fp2 x [opt] )( fp2 y );

		rpd [upd]( fp2 x [opt] );				-- round to precision down: io <= io/x snap down/less (default = 1.0)
		rpd [eval]( fp2 x [opt] )( fp2 y );

		rpi [upd]( fp2 x [opt] );				-- round to precision in: io <= io/x snap toward zero (default = 1.0)
		rpi [eval]( fp2 x [opt] )( fp2 y );

		rpo [upd]( fp2 x [opt] );				-- round to precision out:  io <= io/x snap away from zero (default = 1.0)
		rpo [eval]( fp2 x [opt] )( fp2 y );
		
		rpn [upd]( fp2 x [opt] );				-- round to precision near: io <= io/x snap closest (.5 round out) (default = 1.0)
		rpn [eval]( fp2 x [opt] )( fp2 y );	

		rpn [upd]( fp2 x [opt] ) with helper ( fp2 v, fp2 x )( fp2 y );	-- round to precision near: io <= io/x snap closest ( with .5 helper) 
		rpn [eval]( fp2 x [opt] )( fp2 y ) with helper  ( fp2 v, fp2 x )( fp2 y );
	}

}


type fp10 -- elementary, compatible, conventional
{{
	fp10 is a base-10 floating point number.  
	
	fp10 numbers can exactly represent any number that is
	a power of ten, subject to inherent limits of exponent
	and fraction (mantissa).
}}
{

	general
	{
		begin ( expr vex [opt] );				-- digital expr, default = 0

		begin ( fp10 x );						-- copy

		begin ( fp2 x );						-- fp2 conversion

		begin ( int n );						-- int conversion

		begin<#n> ( word<<#n>> w, expr fex );	-- word conversion


		begin ( mediator [upd], expr fex );		-- mediation

		store ( mediator [upd], expr fex );		-- mediation


		is_equal? ( fp10 x )( bool );
		
		is_before? ( fp10 x )( bool );	

		is_less? ( fp10 x )( bool );

		is_precise? ( fp10 x )( bool );			-- not io/x fractional


		set [upd]( fp10 x );					-- intrinsic assign: io <= x 

		to_int [eval]()( int n );				-- int conversion: n <= io (truncate fraction)

		sgn [eval]()( int s );					-- sign:  s <= {-1,0,1}


		add [upd]( fp10 x );					-- add: io <= io + x 
		add [eval]( fp10 x )( fp10 y );	

		sub [upd]( fp10 x );					-- subtract: io <= io - x 
		sub [eval]( fp10 x )( fp10 y );

		mul [upd]( fp10 x );					-- multiply: io <= io * x
		mul [eval]( fp10 x )( fp10 y );		

		div [upd]( fp10 x );					-- divide: io <= io / x 
		div [eval]( fp10 x )( fp10 y );

	
		neg [upd];								-- negate: io <= -io 
		neg [eval]()( fp10 y );

		abs [upd];								-- abs value: io <= |io|
		abs [eval]()( fp10 y );

		fma [upd]( fp10 m, fp10 b );			-- fused mul add: io <= ( m * io ) + b  (linear transform) 
		fma [eval]( fp10 m, fp10 b )( fp10 y );

		dis [upd]( fp10 x );					-- distance: io <= |(io - x)| (absolute diff)
		dis [eval]( fp10 x )( fp10 y );

		scl [upd]( int n );						-- scale: io <= io * ( 10 ^ n ) (exponent shift)
		scl [eval]( int n )( fp10 y );

		exp [upd]( int n, int d );				-- exponentiate: io <= io ^ (n/d) (rational) 
		exp [eval]( int n, int d )( fp10 y );

		exp [upd]( fp10 x );					-- exponentiate io <= io ^ x (real)
		exp [eval]( fp10 x )( fp10 y );

		log [upd]( fp10 b );					-- log: io <= log base b of io 
		log [eval]( fp10 b )( fp10 y );


		rpu [upd]( fp10 x [opt] );				-- round to precision up: io <= io/x snap up/more (default = 1.0)
		rpu [eval]( fp10 x [opt] )( fp10 y );

		rpd [upd]( fp10 x [opt] );				-- round to precision down: io <= io/x snap down/less (default = 1.0)
		rpd [eval]( fp10 x [opt] )( fp10 y );

		rpi [upd]( fp10 x [opt] );				-- round to precision in: io <= io/x snap toward zero (default = 1.0)
		rpi [eval]( fp10 x [opt] )( fp10 y );

		rpo [upd]( fp10 x [opt] );				-- round to precision out:  io <= io/x snap away from zero (default = 1.0)
		rpo [eval]( fp10 x [opt] )( fp10 y );
		
		rpn [upd]( fp10 x [opt] );				-- round to precision near: io <= io/x snap closest (.5 round out) (default = 1.0)
		rpn [eval]( fp10 x [opt] )( fp10 y );	

		rpn [upd]( fp10 x [opt] ) with helper ( fp10 v, fp10 x )( fp10 y );	-- round to precision near: io <= io/x snap closest ( with .5 helper) 
		rpn [eval]( fp10 x [opt] )( fp10 y ) with helper  ( fp10 v, fp10 x )( fp10 y );
		
	}

}

