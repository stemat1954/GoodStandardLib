
page float in alpha@good


{{
	There are two elementary float types: fp2 (base 2)
	and fp10 (base 10).  Their interfaces are similar
	if not identical, but the type is not generic.  
	
	This page is a work in progress.  Eventually, there
	should be two type defs on the page.
}}


type fp_ -- elementary, compatible (fp2), conventional
{{
	fp is a generic floating point number type.
		

	THOUGHTS...

	what does Good guarantee about conversion 
	to int and decomposition into parts?  Hmmm

	conversion is subject to quit-fail and app
	must predetermine value.

	Decomposition is deprecated.

	word fread/fwrite gives app a way to examine
	and twiddle bits of an fp value.  This is
	alternative to decomposition methods. Word size
	must be compatible with portable format. This is
	clearly an advanced feature.

	inc and dec add and sub epsilon

	div returns remainder 

	rem returns low bits of internal division
	useful for trig calcs??  See C++	remquo.

	see math page for other common
	functions, see C++

		exp, log, trig, hyperbolic,
		stastical, stats

	exp(n,d) can handle special case of 1/2
	(sqrt) and 1/3 (cube rt).  What else?
		
	C++ and IEEE define "hypot" which is
	really used to calc distance/magnitude
	of 2d/3d point/vector.  This should 
	probably be a subroutine (not
	method), since Alpha does not define
	any vector types. UPDATE: yes, alpha
	vector types are available

	undirected rounding is round near.
	One version allows specification of
	directed half rounding.  The other
	version (pure generic rounding) needs
	internal round-to-even for half.

	integer conversion truncates fraction
	and may quit-fail if value is too large
}}
{

	general
	{
		begin ( expr vex [opt] );	-- literal, default = 0

		begin ( fp_ x );  -- copy same

		begin ( fp_ x );  -- copy conversion

		begin<wt> ( <wt> w, expr fex );	-- fread from word

		begin ( message [upd], expr fex );	-- fread from message

		fwrite<wt> ( <wt> w [upd], expr fex );

		fwrite ( message [upd], expr fex );	


		is_equal? ( fp_ x )( bool );
		
		is_before? ( fp_ x )( bool );	

		is_less? ( fp_ x )( bool );

		is_precise? ( fp_ u )( bool );

		to_int ()( int n );	

		set [upd]( fp_ x );  -- replace

		add [upd]( fp_ x );								
		add [eval]( fp_ x )( fp_ );	

		sub [upd]( fp_ x );
		sub [eval]( fp_ x )( fp_ );

		mul [upd]( fp_ x );
		mul [eval]( fp_ x )( fp_ );		

		div [upd]( fp_ x );
		div [eval]( fp_ x )( fp_ );
		div [eval]( fp_ x )( fp_ q, fp_ r );	--  q = "rpn( v/x )", r = "v - q * x" 

		rem [upd]( fp_ x );								-- "v - ( rpn( v/x ) * x )" 
		rem [eval]( fp_ x )( fp_ );		

		pow [upd]( fp_ x );								-- v to x power
		pow [upd]( int n, int d );							-- v to (n/d) power 
		pow [eval]( fp_ x )( fp_ );
		pow [eval]( int n, int d )( fp_ );

		scl [upd]( int n );									-- "v * pow( #, n )"
		scl [eval]( int n )( fp_ );

		fma [upd]( fp_ m, fp_ b );						-- fused mul add 
		fma [eval]( fp_ m, fp_ b )( fp_ );

		dis [upd]( fp_ x );								-- distance between v and x (abs diff)
		dis [eval]( fp_ x )( fp_ );

		neg [upd];									
		neg [eval]()( fp_);

		abs [upd];
		abs [eval]()( fp_ );

		inc [upd];											--  v + epsilon
		inc [eval]()( fp_ );

		dec [upd];											--  v - epsilon
		dec [eval]()( fp_ );

		rpu [upd]( fp_ u [opt] );							-- round to precision up	
		rpu [eval]( fp_ u [opt] )( fp_ );

		rpd [upd]( fp_ u [opt] );							-- round to precision down 
		rpd [eval]( fp_ u [opt] )( fp_ );

		rpi [upd]( fp_ u [opt] );							-- round to precision in
		rpi [eval]( fp_ u [opt] )( fp_ );

		rpo [upd]( fp_ u [opt] );							-- round to precision out
		rpo [eval]( fp_ u [opt] )( fp_ );
		
		rpn [upd]( fp_ u [opt] );							-- round to precision near 
		rpn [eval]( fp_ u [opt] )( fp_ );	

		rpn [upd]( fp_ u [opt] ) with rh ( fp_ x, fp_ u )( fp_ );			-- co-routine for .5
		rpn [eval]( fp_ u [opt] )( fp_ ) with rh ( fp_ x, fp_ u )( fp_ );
	}

}

