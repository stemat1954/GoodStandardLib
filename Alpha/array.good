
page array in alpha@good


nom type array_cursor = tuple<'2'><int>;


type array<t> from ( set<<t>>, sequence<<t>><array_cursor> ) -- compatible and conventional per <t>
{{
	An array<t> is a resizable object set. Objects are
	uniform and logically contiguous in memory.

	<t> is the symbolic object type. The adhoc type must
	be a complete type.  
		
	Methods that require a given index fail if the index is
	invalid. A valid index is between zero and count
	(inclusive).  index = count is a valid insertion index.

	If given index is valid, :insert always works provided 
	there is available memory, and :delete always works by 
	ignoring attempts to remove too many objects.

	Note: delete without an index (default) when array is
	empty doesn't do anything.

	Inserting and deleting at the end of an array is most
	efficient.

	<t> dependent methods supporting initialization,
	external portability, and ordered insertion are pro-
	vided and segrgated in a seperate general group: 
	
		:copy depends on <t>:begin( <t> )

		:move depends on <t>:begin( <t> [upd] )

		:rank depends on <t>:is_before?( <t> )

		:fread depends on <t>:begin( message... )

		:fwrite depends on <t>:fwrite( message... )

	
	NOTE:  <t> dependent compilation errors aren't 
	detected until alpha is translated to sub-alpha.

	An array cursor is bidirectional and represented by
	a pair of ints.  One int carries the current position,
	while the other carries step.  If step is zero, the 
	cursor is inoperable.
}}
{
	general method 
	{
		begin ( int reserve [opt] ); 

		insert [upd] ( int i, int q );		-- q null objs at i

		insert [upd] ( int i [opt] ) = <t> proxy [init];  -- one null obj at i (end), return access

		delete [upd] ( int i, int q );		-- q objs at i, discard all

		delete [upd] ( int i [opt] );		-- one obj at i (end), discard
				
		resize [upd] ( int q );				-- insert or delete at end, new count = q

		reduce [upd];						-- release unused memory
	}
	
	general method -- similar in set<<t>>
	{
		count ()( int );  

		use_object ( int i ) = <t> proxy [eval,init];
	}

	general method  -- <t> dependent 
	{
		fread [upd]( message [upd], expr fex );				-- array image
		fread [upd]( message [upd], expr fex )()( extra );  -- ditto

		fwrite [eval]( message [upd], expr fex );			 -- array immage
		fwrite [eval]( message [upd], expr fex )()( extra ); -- ditto	

		copy [eval]( int i [opt] )( <t> obj );	-- copy from one obj at i (end) TO obj
		copy [upd] ( int i [opt], <t> obj );	-- copy into one null obj at i (end) FROM obj
		copy [upd] ( int i, int q, array<<t>> other, int j [opt] );  -- copy into q null objs at i FROM other at j (0)

		move [upd]( int i [opt] )( <t> obj )		-- move one obj at i (end) TO obj
		move [upd]( int i [opt], <t> obj [upd] );  -- move into one null obj at i (end) FROM obj
		move [upd]( int i, int q, array<<t>> other [upd], int j [opt] ); -- move into q objects at i FROM other at j (0)

		rank [eval]( <t> )( int i, bool unique ); -- find ordered insertion point
	}


	abstract method in set<<t>>
	{
		[final] ~count ()( int n );
		
		[final] ~use_object ( int i ) = <t> proxy;
	}

	abstract method in sequence<<t>><array_cursor>
	{
		[final] ~open_cursor ( int )( array_cursor );  

		[final] ~move_cursor ( array_cursor [upd] );

		[final] ~flip_cursor ( array_cursor [upd] ); 

		[final] ~use_object ( array_cursor ) = <t> proxy; 
	}
}


