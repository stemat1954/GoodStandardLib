
page array in alpha@good


nom type array_cursor = tuple<'2'><int>;

type array<t> from ( set<<t>>, sequence<<t>><array_cursor> ) -- compatible and conventional per <t>
{{
	An array<t> is a resizable object set. Objects are
	uniform and logically contiguous in memory.

	<t> is the symbolic object type. The adhoc type must
	be a complete type.  
		
	Methods that require a given index quit if the index is
	invalid. A valid index is between zero and count
	(inclusive).  index = count is a valid insertion index.

	If given index is valid, :insert always works provided 
	there is available memory, and :delete always works by 
	ignoring attempts to remove too many objects.

	Note: delete without an index (default) when array is
	empty doesn't do anything.

	Inserting and deleting at the end of an array is most
	efficient.

	An array can be configured from any type <t> but some
	methods can only be called with a type dependent co-
	routine.  See stock dialect for standard coroutines.

	Note: This technique verifies type compatibility and
	adds flexibility.

	An array cursor is bidirectional and represented by
	a pair of ints.  One int carries the current position,
	while the other carries step.  If step is zero, the 
	cursor is inoperable.
}}
{
	general method 
	{
		begin ( int reserve [opt] ); 

		begin ( array<<t>> other upd );		-- move

		insert [upd]( int i, int q );		-- q null objs at i

		insert [upd]( int i [opt] ) = <t> proxy [init];  -- one null obj at i (end), return access

		delete [upd]( int i, int q );		-- q objs at i, discard all

		delete [upd]( int i [opt] );		-- one obj at i (end), discard
				
		resize [upd]( int q );				-- insert or delete at end, new count = q

		shrink [upd];						-- release unused memory
	}
	
	general method -- similar in set<<t>>
	{
		count ()( int );  

		use_object ( int i ) = <t> proxy [eval,init];
	}

	general method  -- <t> dependent 
	{
		load [upd]( array<<t>> other ) with copy ( <t> )( <t> );
		load [upd]( message [upd], expr fex ) with fread ( message [upd], expr fex )( <t> );	
		load [upd]( message [upd], expr fex )()( extra ) with fread ( message [upd], expr fex )( <t> )( extra ); 

		fwrite [eval]( message [upd], expr fex ) with fwrite ( message [upd], expr fex, <t> );
		fwrite [eval]( message [upd], expr fex )()( extra ) with fwrite ( message [upd], expr fex, <t> )()( extra );

		copy [eval]( int i [opt] )( <t> obj ) with copy ( <t> )( <t> );						-- from one obj at i (end) TO obj
		copy [upd]( int i [opt], <t> obj ) with copy ( <t> )( <t> );						-- into one null obj at i (end) FROM obj
		copy [upd]( int i, int q, array<<t>> other, int j [opt] ) with copy ( <t> )( <t> ); -- into q null objs at i FROM other at j (0)

		move [upd]( int i [opt] )( <t> obj ) with move ( <t> [upd] )( <t> );				-- ditto copy 
		move [upd]( int i [opt], <t> obj [upd] ) with move ( <t> [upd] )( <t> );
		move [upd]( int i, int q, array<<t>> other [upd], int j [opt] ) with move ( <t> [upd] )( <t> );

		rank [eval]( <t> )( int i, bool unique ) with is_before? ( <t> a, <t> b )( bool ); -- find ordered insertion point
	}


	abstract method in set<<t>>
	{
		[final] ~count ()( int n );
		
		[final] ~use_object ( int i ) = <t> proxy;
	}

	abstract method in sequence<<t>><array_cursor>
	{
		[final] ~open_cursor ( int )( array_cursor );  

		[final] ~move_cursor ( array_cursor [upd] );

		[final] ~flip_cursor ( array_cursor [upd] ); 

		[final] ~use_object ( array_cursor ) = <t> proxy; 
	}
}


