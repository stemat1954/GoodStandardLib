
page array in alpha@good


type array_cursor<t>;


type array<t> from ( uniform_set<<t>>, serial_set<<t>>< array_cursor<<t>>> ) -- conventional
{{
	An array<t> is a resizable object set.  Objects are
	uniform and logically contiguous in memory.

	<t> is the symbolic object type. The adhoc type must
	be a complete type.  
		
	Methods that require a given index fail if the index is
	invalid. A valid index is between zero and count
	(inclusive).  index = count is a valid insertion index.

	If given index is valid, :insert always works provided 
	there is available memory, and :delete always works by 
	ignoring attempts to remove too many objects.

	Note: delete without an index (default) when array is
	empty doesn't do anything.

	Inserting and deleting at the end of an array is most
	efficient.

	<t> dependent base methods supporting initialization,
	external portability, and ordered insertion are pro-
	vided.  They're adapted via an associated abstract 
	interface.  
	
	Note:  See page array in stock@good for permutable 
	array types.
}}
{
	general method
	{
		begin ( int reserve [opt] ); -- empty

		insert [upd] ( int i, int q );		-- q null objs at i

		insert [upd] ( int i [opt] ) = <t> proxy [init];  -- one null obj at i (end), return access

		delete [upd] ( int i, int q );		-- q objs at i, discard all

		delete [upd] ( int i [opt] );		-- one obj at i (end), discard
				
		resize [upd] ( int q );				-- insert or delete at end, new count = q

		reduce [upd];						-- release unused memory
	}
	
	general method -- similar in uniform_set<<t>>
	{
		count ()( int );  

		use_object ( int i ) = <t> proxy [eval,init];
	}

	base method  -- <t> dependent
	{
		fread [upd] ( message [upd], expr fex )()( extra ); 

		fwrite ( message [upd], expr fex )()( extra );	

		copy [upd] ( int i, int q, array<<t>> other, int j [opt] );	-- init-by-copy q objs at i from other at j (0)
		
		relay [upd] ( int i, int q, array<<t>> other [upd], int j [opt] ); -- init-by-relay q objects at i from other at j (0)

		rank ( <t> )( int i, bool unique ); -- find ordered insertion point
	}

	abstract method
	{
		~copy ( <t> )( <t> )
		{
			quit fault ( 'bug', 'no adapter' );
		}

		~relay ( <t> [upd] )( <t> )
		{
			quit fault ( 'bug', 'no adapter' );
		}
		
		~fread ( message [upd], expr fex )( <t> )( extra )
		{
			quit fault ( 'bug', 'no adapter' );
		}

		~fwrite ( message [upd], expr fex, <t> )()( extra )
		{
			quit fault ( 'bug', 'no adapter' );
		}

		~before? ( <t> a, <t> b )( bool yes )
		{
			quit fault ( 'bug', 'no adapter' );
		}
	}

	abstract method in uniform_set< <t> >
	{
		[final] ~count ()( int n );
		
		[final] ~use_object ( int i ) = <t> proxy;
	}

	abstract method in serial_set< <t> >< array_cursor< <t> > >
	{
		[final] ~open_cursor ( int )( array_cursor<<t>> );  

		[final] ~move_cursor ( array_cursor<<t>> [upd] );

		[final] ~flip_cursor ( array_cursor<<t>> [upd] ); 

		[final] ~use_object ( array_cursor<<t>> ) = <t> proxy; 
	}
}

