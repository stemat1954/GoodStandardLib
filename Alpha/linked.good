
page link in alpha@good


type linked<t>   -- intrinsic
{{
	A linked<t> object is a link object that creates and/or 
	accesses another object of type <t> in global storage.

	Note:  Conceptually, a linked<t> object is a generic
	type that derives from an internal and universal link
	type.  The term "link" applies to any adhoc linked 
	object.

	Links are used to create objects at runtime in global
	storage.  The type of object created must be a complete
	type, but the link's adhoc type can be any base type
	of the object created.  Conversely, the type of object 
	created by a link must be related to the link's adhoc
	type (same type or subtype).
		
	Logically, a link is a runtime reference object. That
	is, the binding of link to object is made at runtime.
	In this sense, links are similar to proxies.  However, 
	links are first class objects with methods (proxies
	aren't) and access to a link's bound object requires
	an explicit accessor call, while access to a proxy's
	bound object is implicit.
	
	A link's object accessor method is called :use.  Like
	other accessors, :use returns a result proxy, which
	can be used in any object context as a reference to the
	global object. Thus, logically, there are two levels of
	indirection to get to a linked object.
	
	Note:  In a sense, :use converts a link into a proxy.  
	The conversion is optimized and may in fact be virtual.
	
	Note:  adhoc type <object> is allowed for <t> because 
	ultimately <t> is the stated type of a result proxy
	returned by :use.  

	The proxy returned by :use has [upd] access and it can 
	be used to call any method of <t> except :begin.  To
	initialize the global object, call :use_new to get an
	[init] proxy.

	The object bound to a link is created when the link 
	is initialized. 
	
	The object created by :begin is null and it must be
	initialized before it can be used.  Thus, it's common 
	to see two levels of initialization when a link is
	created. This expression:
	
		linked<thing> lt begin:use_new:begin; 

	creates and initializes a link named lt, bound to a
	global object of adhoc type thing, then accesses the 
	object with :use_new to initialize the global object
	using default :begin.  

	Note:  It's important to distinquish between a null
	link and a possibly null object accessed by the link.
	A null link can't be dereferenced, but a properly 
	intialized link always binds an object that may or may
	not be null.
	
	A new link can be initialized by copying an existing
	compatible link. When links are copied, the new
	link is bound to the existing global object. A new
	object is not created.  
	
	The global object bound to a link (or links) is 
	automatically deleted when all links that reference 
	the object are deleted.  It is common to say that the
	global object bound to one or more links is "reference
	counted."

	Note:  Copying links and reference counting is
	thread-safe. Links are essential for sharing objects
	between threads.

	An existing link is compatible with another link
	if the two adhoc link types are related.
	
	For example:


	type thing
	{
		general method foo [eval];
	}

	type widget from thing
	{
		general method goo [eval];
	}

	subroutine foo
	{
		linked<widget> lw:begin:use_new:begin; -- new link to widget
		linked<thing> lt:begin( lw );  -- copy pw

		lw:use:foo;	-- ok (foo is inherited)
		lw:use:goo;	-- ok

		lt:use:foo;	-- ok
		lt:use:goo;	-- error! (goo not in thing)
		lt:use:as<widget>:goo;  -- ok
	}
		


	In general, two types are related and compatible if they
	occur in a common type hierarchy.

	      A
	     / \
		B   C

	In this (bottom-up) hierarchy, A derives from B and C.
	A, B, and C are all related.  Note that B and C are
	related through A, but are otherwise not related.

	If la is a link to an actual object of type A,

		linked<A> la:begin:use_new:begin;

	then 

		linked<B> lb:begin( la );
		linked<C> lc:begin( la );

		linked<B> lb2:begin( lc );
		linked<C> lc2:begin( lb );

	are all legit and refer to the same actual object
	pointed to by la.

	This works because 

	  la:use:base<B>
	  la:use:base<C>
	  lb:use:as<A>
	  lc:use:as<A>
	  lb:use:as<C>
	  lc:use:as<B>

	are all legit and return valid proxies that also 
	reference the original actual object.

	Links can be used to create logically heterogenous 
	arrays. They're also essential for creating dynamically
	linked object collections like trees, lists, and 
	networks.

	Links are not portable.  However, since a link can
	be created from a typename, and those ARE portable, 
	applications can devise ways to persist	and restore
	links.

	Although a single link is relatively easy to persist, 
	a complex network of links is significantly	more
	difficult. In general, applications usually have to 
	devise a scheme to store links and objects separately.

	The basic idea is to create a portable link using a 
	typename and some other portable reference, e.g. an int
	that indexes an object in a set of objects.

	A portable link of this sort can be imported as a 
	typename and int.  The typename is used to create a	link
	to a null object and the int can be used to lookup a 
	copy of the object for initialization.  Of course, where 
	objects may have multiple links, there has to be a way
	to recognize when an original link has been restored so
	that others can copy it.

	Links can be compared using standard methods. Cross
	type comparisions are allowed, even if the links are
	copy-incompatible.  Comparisons are based on object 
	storage address, so equal links reference the same 
	actual object.  Furthermore, if a:before?(b) is false 
	and b:before?(a) is false, then a and b are par equal
	( "a |par| b" is true).
		
	Note:  Par equality is persistent provided network 
	linkage is properly restored using techniques already 
	described.  However, ordinality is a completely trans-
	ient property and any ordered collection of links 
	is only ordered for a single runtime session.

	Note: In some applications, it may be preferable to
	compare links by passing the comparison on to the 
	linked object.  A general solution is too complicated.
	For particular scenarios, an application can define a 
	new type that encapsulates a link and provides the
	desired pass-through methods.


}}
{
	general 
	{
		begin;						-- create and bind null <t> object, complete <t>

		begin ( typename );			-- create and bind null object, named type is complete type or subtype of <t> (may fail)

		begin<xt> ( linked<<xt>> );	-- copy compatible link, <xt> related to <t>  (may fail)
	
		use_new = <t> proxy [init]; -- void if <t> not actual

		use = <t> proxy [upd];	

		is_equal<xt>? ( linked<<xt>> )( bool );

		is_before<xt>? ( linked<<xt>> )( bool );
	}
}

