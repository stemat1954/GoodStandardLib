
page vector in AlphaByGood


type vector<t><#n> from direct_access<<t>>
{{
	algebraic vector.
	
	numeric type <t> = int,	fp2, fp10, cplx

	<#n> dimension (number of coordinates)
}}
{
	nom type vector_tn = vector<<t>><<#n>>;

	general method
	{
		begin;												-- zero vector

		begin ( vector_tn other );							-- copy

		begin<xt><#xn> ( vector<<xt>><<#xn>> other );		-- conversion 

		begin ( <t> x, <t> y, <t> z [opt], <t> w [opt] )()( extra );	-- coordinate list

		begin<xt><c> ( serial_access<<xt>><<c>> source );	-- coordinate source, numeric <xt> 


		begin ( mediator m [upd], expr fex )()( extra );	-- mediation

		store ( mediator m [upd], expr fex )()( extra );	-- mediation

	
		is_equal? ( vector_tn v )( bool );

		is_zero? ()( bool );


		set_coord [upd]( int i, <t> n );

		get_coord [eval]( int i )( <t> n );

		use_coord [eval]( int i ) = <t> proxy [eval,init];

		get_coords [eval]()( array<<t>><<#n>> );			


		add [upd]( vector_tn v );					-- add: io.xi <= io.xi + v.xi 
		add [eval]( vector_tn v )( vector_tn v2 );		

		sub [upd]( vector_tn v );					-- subtract: io.xi <= io.xi - v.xi 
		sub [eval]( vector_tn v )( vector_tn v2 );

		mul [upd]( <t> n );							-- multiply: io.xi <= io.xi * n 
		mul [eval]( <t> n )( vector_tn v );

		div [upd]( <t> n );							-- divide: io.xi <= io.xi / n 
		div [eval]( <t> n )( vector_tn v ); 

		neg [upd];									-- negate: io.xi <= -io.xi 
		neg [eval]()( vector_tn v );

		dot [eval]( vector_tn v [opt] )( <t> n );	-- dot product: n <= sum io.xi * v.xi ( default v = io )

		ltf [upd]( sq_matrix<<t>><<#n>> );			-- linear transform #n -> #n
		ltf [eval]( sq_matrix<<t>><<#n>> )( vector_tn v );	

		ltf<#xn> [eval]( matrix<<t>><<#xn>><<#n>> )( vector<<t>><<#xn>>);	-- linear transform #n -> #xn
	}


	abstract method in direct_access<<t>>
	{
		[final]	~count ()( int );	

		[final] ~use@ ( int i ) = <t> proxy; 
	}

}

