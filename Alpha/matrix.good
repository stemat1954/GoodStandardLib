
page matrix in AlphaByGood


type matrix<t><#r><#c>
{{
	rectangular algebraic matrix.
	
	numeric type <t> ( int, fp2, fp10 )

	<#r> rows, <#c> columns 

	Use sq_matrix<t><#n> when <#r> and <#c> are same.

	When filling a matrix from a serial source, columns are
	filled row-wise (row-by-row).  If the source is exhaust-
	ed before the matrix is filled, remaining entries will
	be zero.  The source type must be numeric. If it differs
	from the matrix type, it's converted and possibly 
	rounded using :rpn( '1.0' ).
}}
{
	nom type row_vector = vector<<t>><<#c>>;

	nom type col_vector = vector<<t>><<#r>>;

	nom type matrix_trc = matrix<<t>><<#r>><<#c>>;  -- same shape


	general method
	{

		begin;										-- zero matrix

		begin ( matrix_trc other );					-- copy

		begin<xt><c> ( serial_access<<xt>><<c>> source ); -- fill, see notes
		
		begin ( mediator m [upd], expr fex );		-- mediation

		store ( mediator m [upd], expr fex );		-- mediation

	
		is_zero? ()( bool );
	

		set_row [upd]( int i, row_vector rv );

		get_row [eval]( int i )( row_vector rv );


		set_col [upd]( int j, col_vector cv );

		get_col [eval]( int j )( col_vector cv );

		
		set_entry [upd]( int i, int j, <t> n );

		get_entry [eval]( int i, int j )( <t> n );

		use_entry [eval]( int i, int j ) = <t> proxy [eval,init];


		add [upd]( matrix_trc m );					-- io <= io + m (add)
		add [eval]( matrix_trc m1 )( matrix_trc m2 );

		sub [upd]( matrix_trc m );					-- io <= io - m (subtract)
		sub [eval]( matrix_trc m1 )( matrix_trc m2 );

		mul [upd]( <t> n );							-- io <= io * n (multiply)
		mul [eval]( <t> n )( matrix_trc m );

		div [upd]( <t> n );							-- io <= io / n (divide)
		div [eval]( <t> n )( matrix_trc m ); 

		neg [upd];									-- io <= -io (negate)
		neg [eval]()( matrix_trc m );
				
		dot<#n> [eval]( matrix<<t>><<#c>><<#n>> m1 )( matrix<<t>><<#r>><<#n>> m2 );  -- dot product

		dot [eval]( row_vector v1 )( col_vector v2 );  -- io <= io dot v (transform v, #c -> #r)

	}

}


type sq_matrix<t><#> from matrix<<t>><<#>><<#>>
{{
	square algebraic matrix

}}
{
	nom type vector_tn = vector<<t>><<#>>;

	nom type sq_matrix_tn = sq_matrix<<t>><<#>>;


	general method
	{
		begin;										-- zero matrix

		begin ( sq_matrix_tn other );				-- copy

		begin<xt><c> ( serial_access<<xt>><<c>> source );	-- fill

		begin ( mediator m [upd], expr fex )()( extra );	-- mediation

		store ( mediator m [upd], expr fex )()( extra );	-- mediation
				

		is_diag? ()( bool );

		is_ident? ()( bool );


		set_diag [upd]( vector_tn v [opt] );	-- default = identity

		get_diag [eval]()( vector_tn v );


		invert [eval]()( sq_matrix_tn );		-- null if not invertible
	}
}