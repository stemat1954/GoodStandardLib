
page link in alpha@good


type <t>link   -- intrinsic
{{
	A <t>link object is an object that creates and/or 
	accesses another object of type <t> in global storage.

	Links are used to create objects at runtime in global
	storage. The type of object created must be a complete
	type, but in general, a link's adhoc type can be any
	related (possibly incomplete) type.  

	Note: The link that creates an object must a complete
	adhoc type, but links that copy other links need only
	be related.
	
	Logically, a link is a runtime reference object. That
	is, the binding of link to object is made at runtime.
	In this sense, links are similar to proxies.  However, 
	links are first class objects with methods (proxies
	aren't) and access to a link's bound object requires
	an explicit accessor call, while access to a proxy's
	bound object is implicit.
	
	A link's object accessor method is called :use.  Like
	other accessors, :use returns a result proxy, which
	can be used in any object context as a reference to the
	global object. Thus, logically, there are two levels of
	indirection to get to a linked object.
	
	Note:  In a sense, :use converts a link into a proxy.  
	The conversion is optimized and may in fact be virtual.
	
 	The proxy returned by :use has [upd] access and it can 
	be used to call any method of <t> except :begin.  To
	initialize the global object, call :use_actual to
	get an [init] proxy.

	The object bound to a link is created when the link 
	is initialized. 
	
	The object created by :begin is null and it must be
	initialized before it can be used.  Thus, it's common 
	to see two levels of initialization when a link is
	created. This expression:
	
		<thing>link tl begin:use_actual:begin; 

	creates and initializes a link named tl, bound to a
	global object of adhoc type thing, then accesses the 
	object with :use_actual to initialize the global
	object with default :begin.  

	Note: It would be possible to eliminate :use_actual
	in favor of :use:as_actual<t> but the specialized method 
	is potentially more efficient and avoids redundant type
	specification in a typical initialization sequence.

	Note:  It's important to distinquish between a null
	link and a possibly null object accessed by the link.
	A null link can't be used, but a properly intialized 
	link can always be used and it may or may not bind
	a null global object.
	
	A link can be initialized by copying an existing 
	compatible link. When links are copied, the new link
	is bound to some external subobject of the existing
	global object. 
	
	The global object bound to a link is automatically
	deleted when all links that reference the object are
	deleted.
	
	Note:  It's common to say that the global object bound 
	to a link is "reference counted."

	Note:  Copying links and reference counting is thread-
	safe. Links are essential for sharing objects between
	threads.

	An existing link is compatible with another link if 
	the two adhoc link types are related.
	
	For example:


	type thing
	{
		general method foo [eval];
	}

	type widget from thing
	{
		general method goo [eval];
	}

	subroutine foo
	{
		<widget>link wl:begin:use_actual:begin; -- new link to actual widget
		<thing>link tl:begin( wl );  -- copy wl

		wl:use:foo;	-- ok (foo is inherited)
		wl:use:goo;	-- ok

		tl:use:foo;	-- ok
		tl:use:goo;	-- error! (goo not a method of thing)
		tl:use:as<widget>:goo;  -- ok after type translation
	}
		

	In general, two types are related and compatible if they
	occur in a common type hierarchy.

	      A
	     / \
		B   C

	In this (bottom-up) hierarchy, A derives from B and C.
	A, B, and C are all related.  Note that B and C are
	related through A, but are otherwise not related.

	If al is a link to an actual object of type A,

		<A>link al:begin:use_actual:begin;

	then 

		<B>link bl:begin( al );
		<C>link cl:begin( al );

		<B>link bl2:begin( cl );
		<C>link cl2:begin( bl );

	are all legit and refer to the same actual object bound
	to la.

	This works because 

	  al:use:as_base<B>
	  al:use:as_base<C>
	  bl:use:as<A>
	  cl:use:as<A>
	  bl:use:as<C>
	  cl:use:as<B>

	are all legit and return valid proxies.

	Links can be used to create logically heterogenous 
	arrays. They're also essential for creating dynamically
	linked object collections like trees, lists, and 
	networks.

	Links are not portable.  However, since a link can
	be created from a typename, and typenames ARE portable, 
	applications can devise ways to persist	and restore
	links.

	Although a single link is relatively easy to persist, 
	a complex network of links is significantly	more
	difficult. In general, applications usually have to 
	devise a scheme to store links and objects separately.

	The basic idea is to create a portable link using a 
	typename and some other portable reference, e.g. an int
	that indexes an object in a set of objects.

	A portable link of this sort can be imported as a 
	typename and int.  The typename is used to create a	link
	to a null object and the int can be used to lookup a 
	copy of the object for initialization.  Of course, where 
	objects may have multiple links, there has to be a way
	to recognize when an original link has been restored so
	that others can copy it.

	Links can be compared using standard methods. Cross
	type comparisions are allowed, even if the links are
	copy-incompatible.  Comparisons are based on object 
	storage address, so equal links reference the same 
	actual object.  Furthermore, if a:before?(b) is false 
	and b:before?(a) is false, then a and b are par equal
	( "a |par| b" is true).
		
	Note:  Par equality is persistent provided network 
	linkage is properly restored using techniques already 
	described.  However, ordinality is a completely trans-
	ient property and any ordered collection of links 
	is only ordered for a single runtime session.

	Note: In some applications, it may be preferable to
	compare links by passing the comparison on to the 
	linked object.  A general solution is too complicated.
	For particular scenarios, an application can define a 
	new type that encapsulates a link and provides the
	desired pass-through methods.


}}
{
	general 
	{
		begin;						-- create and bind null <t> object, complete <t> (may quit)

		begin ( typename );			-- create and bind null <t> object, typename:is<t>? must be true (may quit)

		begin<xt> ( <<xt>>link );	-- copy compatible link, <xt> related to <t> (may quit)
	
		use = <t> proxy [upd];		-- always works (never void)

		use_actual = <t> proxy [init]; -- if <t> is actual object type (may be void)

		is_equal<xt>? ( <<xt>>link )( bool );

		is_before<xt>? ( <<xt>>link )( bool );
	}
}

