
page utc in alpha@good


common double<int> utc_origin [const];	


type utc  -- conventional
{{
	A utc is a point in UTC (coordinated universal time)
	(real) time.

	Utc values enumerate discrete points (ticks) along 
	a utc time line.  They have cardinality and ordinality. 
	The time line origin coincides with hypothetical day 
	zero in the Gregorian calendar, and clock time zero 
	(midnight) for a clock located on the prime meridian
	(Greenwich).

	Ticks are spaced a millisec apart and utc values are
	relative to a defined origin named utc_origin.  The 
	relative origin is a double<int> (y,d) where y is a 
	number of years and d is a number of days counted from
	the absolute Gregorian origin. Thus, utc value 0 
	identifies a point in UTC time that coincides with
	utc_origin.
		
	A utc tick value is synchronized to an internal real
	time clock that is in turn synchronized (in principal)
	to UTC.  A real time value is captured when a utc object 
	is initialized. It can be resynchronized by calling 
	:update.

	Given utc_origin, a utc, and a time zone, an equi-
	valent calendar date and clock time can be derived 
	for that utc in that time zone.
		
	Note: This functionality is not Alpha. See stock
	conversion subroutines.
		
	To support derivation of calendar date and clock time,
	:analyze converts a utc value to a double<int>(d,t)
	where d is a count of days from utc_origin and t is a
	count of millisecs in the day, where 0 < t < 86,401,000.  

	d and t incorporate leap days and known leap seconds.
	Any value t >= 86,400,000 is within a leap second on
	day d. 
		
	Leap seconds are not regular and any leap second intro-
	duced after release of a Pragma implementation may or
	may not be known, depending on the execution platform.
		
	Since int precision on every Pragma implementation is
	at least 32 bits, there is enough range in the number
	of days to allow about 5.883 million years of real 
	time utc values.  This range also ensures that a single
	utc_origin will suffice for all practical time. 
		
	Note: Clearly, internal utc values must have 64	bits
	of total precision.

	Unlike calendar dates and clock times, a utc object 
	can be calculated.
		
	The arithmetic difference between two utc's is an 
	etm (elapsed time) and adding an etm to a utc results
	in a new utc.  See alpha\etm for more info.
		
	Note that the elapsed time between two ticks that
	have the exact same clock time on two consecutive
	days is usually, but not necessarily, 24 hours. If
	there is a leap second in the interval, the elapsed
	time will be 24 hours and one second. 
		
	Likewise, if a 24 hour elapsed time is added to a tick
	that falls on a day with a leap second, the resulting
	tick will have a clock time that is one second earlier
	the next day.

	Similar reasoning applies to dates in consecutive years
	that have an intervening leap day.

	Many applications can ignore this technicality in 
	practice, but it's an important consideration.

	A utc object is portable. See Alpha type reference for
	supported formats.

	Note: text formats express utc as calander date and 
	time for some timezone specified in the fex.  Various 
	text formats are supported.  Text message initialization
	and literal	vex initialization are consistent.

}}
{

	general
	{
		begin ( expr vex [opt] );			-- literal, default = "now"

		begin ( double<int> );				-- specify (d,t)

		begin ( utc other );				-- copy

		begin ( message [upd], expr fex );	-- fread

		fwrite ( message [upd], expr fex );


		equal? ( utc t )( bool );

		before? ( utc t )( bool );

		less? ( utc t )( bool );	

	
		update [upd];		-- "now"

		analyze ()( double<int> );	-- (d,t)

		add [upd]( etm t );
		add [eval]( etm t )( utc );

		sub ( utc t )( etm );
	}
}

