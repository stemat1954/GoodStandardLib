
page access in alpha@good



type direct_access<t> [incomplete] -- intrinsic
{{
	direct_access<t> is a generic base type for collections
	that provide direct access to objects in the collection.
		
	<t> is the symbolic object type. 

	Collections that derive from direct_access<t> manage a
	countable set of objects.  Individual objects are
	directly accessed by a numeric position index.

	Valid indexes range from zero to count - 1.

	:use returns a deferred-access proxy. If the index is
	out	of range, the proxy will be void.

	Direct access collections are naturally ordered by index,
	but there is no presumption objects with a lesser index
	are less than or before objects with a greater index.

	direct_access collections can be scanned in a Good for
	loop.
}}
{
	general 
	{
		begin;

		count ()( int n );

		use ( int i ) = <t> proxy;
	}

	abstract -- [tbd] in subtype (not fundamental)
	{
		~count ()( int );	

		~use ( int i ) = <t> proxy; 
	}
}



type serial_access<t><c> [incomplete] -- intrinsic
{{
	serial_access<t> is a generic base type for collections
	that provide serial access to objects in the collection.
		
	<t> is the symbolic object type and <c> is the symbol 
	cursor type. 
	
	Collections that derive from serial_access<t><c> manage
	an ordered collection of objects.  Individual objects 
	are accessed in serial order using a bespoke cursor.

	Access to a serial collection starts by opening a cursor
	positioned at either end of the collection. The	cursor
	moves toward the other end in increments or steps.  A 
	positive or negative step determines direction and 
	resolution of the cursor. 
	
	Generally, a serial cursor must have a final inoperable
	state that doesn't provide access to an object. An in-
	operable cursor must be accepted by all methods.

	:open_cursor( step ) creates an original cursor placed 
	at either end of the set.  If step is positive, the 
	cursor is placed on the first object and moves toward
	the last.  If step is negative, the cursor is placed on 
	the last object and moves toward the first.  step = 0 
	is invalid.  The default step is one.

	Note: If a collection doesn't support step < 0 or |step|
	> 1, the output cursor is inoperable.

	:move_cursor updates the position of a given cursor.
	
	:flip_cursor reverses the direction of a given cursor.

	Note: If a cursor can't be flipped, the given cursor
	will be made inoperable.

	:access returns a deferred-access proxy. If the cursor
	is inoperable, the proxy will be void.

	serial_access collections can be scanned in a Good for
	loop.
}}
{
	general
	{
		begin;

		open_cursor ( int step [opt] )( <c> );

		move_cursor ( <c> [upd] );

		flip_cursor ( <c> [upd] );

		use ( <c> ) = <t> proxy;
	}


	abstract  -- [tbd] in subtype (not fundamental)
	{
		~open_cursor ( int )( <c> );  

		~move_cursor ( <c> [upd] );

		~flip_cursor ( <c> [upd]);

		~use ( <c> ) = <t> proxy; 
	}

}



