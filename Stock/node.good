
page node in StockByGood


{{
	On this page:
	
	node_link
	node			variable-way base

	node<#>_link
	node<#>			generic fixed-way base 
	<t>node<#>		generic fixed-way synthetic node 

	node1_link
	node1			specialized one-way base
	<t>node1		specialized one-way synthetic node
}}


nom type node_link = smp<node>;

type node [incomplete]
{{
	A node is a multi-link adapatable base type.
	
	Nodes interconnect with other nodes using indexed links.

	A node can have any number of links and link allocation
	is dynamic.  
	
	This node type is used when a nexus interconnects in 
	diverse ways. 

	When node dimension is known and uniform, use a node<#>
	instead.
}}
{

	general method
	{
		begin ( int dim [opt] )
		{
			io.linkage:begin( dim );
		}

		get_link ( int i )( node_link nl )
		{
			nl:begin( io.linkage:use_object( i ) );
		}

		set_link [upd]( int i, node_link nl )
		{
			io:make_room( i );
			io.linkage:use_object( i )[init] <= nl;
		}

		unlink [upd]( int i )
		{
			io.linkage:use_object( i )[init]:reuse;
		}
	}

	misc method
	{
		make_room [upd]( int i )
		{
			io.linkage:count()( int q );
			int need:begin( "i - q + one" );	--i:sub( q )( =int ):add( one )( int need );
			if ( "need |>| zero" ) io.linkage:insert( q, need ); -- at i = q
		}
	}

	nom type linkage = <node_link>array;

	instance
	{
		linkage;
	}
}



nom type node<#>_link = smp<node<<#>>>;


type node<#> [incomplete]
{{
	A node<#> is a generic fixed dimension node.
	
	node<#> linkage is uniform.  That is, all nodes in a
	<#n>-way nexus are of the same dimension.

	A node<#> is technically complete, but doesn't have any
	practical application as an actual type. It should be 
	used as a base type for application	types.

	node<'1'> is valid, but specialized node1 is a better
	alternative.
}}
{
	nom type linkage = < node<<#>>_link >tuple<<#>>;

	general method
	{
		begin  -- all links null
		{
			io.linkage:begin;  -- all links null
		}

		get_link ( int i )( node<<#>>_link nl ) 
		{
			io.linkage:use_object( i ) ~nl;
			if ( "is_not_null?( ~nl )" ) nl:begin( ~nl );
		}

		set_link [upd](int i, node<<#>>_link nl )
		{
			io.linkage:use_object( i ) <= nl;
		}

		unlink [upd]( int i )
		{
			io.linkage:use_object( i ):reuse;
		}
	}

	instance
	{
		linkage;
	}
}


type <t>node<#> from ( <t>, node<<#>> )
{{
	A <t>node<#> is a generic synthetic node.

	<t> must be a complete type, or it can be an incomplete
	type if it doesn't have any [tbd] abstract methods
	(which forces the synthetic node to be incomplete).

	All methods are inherited from base types.  

	General :begin uses a co-routine to initialize
	application type <t>.

	Default :begin can be used if default <t>:begin
	is available.

	Synthetic nodes of the same dimension and related
	types can interlink.

	Usually, applications will turn some type <t> into
	a linkable type by defining a particular nom type
	for <t>.  For example
	
		nom type thing_node = <thing>node<'2'>.
}}
{
	general method
	{
		begin
		{
			io:base< node<<#>> >:begin;
			io:base<<t>>:begin;
		}

		begin with co_begin ()( <t> )
		{
			io:base< node<<#>> >:begin;
			co_begin()( io:base<<t>> );
		}
	}
}


nom type node1_link = smp<node1>;

type node1 
{{
	A node1 is a specialized one-way node.
}}
{
	general method
	{
		begin  -- null link
		{
		}

		get_link ()( node1_link nl )
		{
			if ( "is_not_null?( io.link )" ) nl:begin( io.link );
		}

		set_link [upd]( node1_link nl )
		{
			io.link:reuse:begin( nl );
		}

		unlink [upd]
		{
			io.link:reuse;
		}
	}

	instance
	{
		node1_link link;
	}
}


type <t>node1 from ( <t>, node1 )
{{
	specialized synthetic node1
}}
{
	general method
	{
		begin
		{
			io:base<node1>:begin;
			io:base<<t>>:begin;
		}

		begin with co_begin ()( <t> )
		{
			io:base<node1>:begin;
			co_begin()( io:base<<t>> );
		}
	}
}




