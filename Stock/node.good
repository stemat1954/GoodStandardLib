
page node in StockByGood


{{
	On this page:
	
	node			variable-way base

	node<#>			generic fixed-way base 
	<t>node<#>		generic fixed-way synthetic node 

	node1			specialized one-way base
	<t>node1		specialized one-way synthetic node
}}



type node [incomplete]
{{
	A node is a linkable object.
	
	Nodes interconnect with other nodes using indexed links.

	A node can have any number of links and link allocation
	is dynamic.  
	
	When node dimension is known and uniform, use a node<#>
	instead.
}}
{
	nom type link = smp<node>;
	nom type linkage = <link>array;


	general method
	{
		begin ( int dim [opt] )
		{
			io.linkage:begin( dim );
		}

		get_link ( int i )( link )
		{
			given\link:begin( io.linkage:use_object( i ) );
		}

		set_link [upd]( int i, link )
		{
			io:make_room( i );
			io.linkage:use_object( i )[init] <= given\link;
		}

		unlink [upd]( int i )
		{
			io.linkage:use_object( i )[init]:reuse;
		}
	}

	misc method
	{
		make_room [upd]( int i )
		{
			io.linkage:count()( int q );
			int need:begin( "i - q + one" );	--i:sub( q )( =int ):add( one )( int need );
			if ( "need |>| zero" ) io.linkage:insert( q, need ); -- at i = q
		}
	}

	instance
	{
		linkage;
	}
}



type node<#> [incomplete]
{{
	A node<#> is an interlinkable object with fixed number
	of links.
	
	node<#> linkage is uniform.  That is, all nodes in a
	<#n>-way nexus are of the same dimension.

	A node<#> is technically complete, but doesn't have any
	practical application as an actual type. It should be 
	used as a base type for application	types.

	node<'1'> is valid, but specialized node1 is a better
	alternative.
}}
{
	nom type link = smp<node<<#>>>;
	nom type linkage = <link>tuple<<#>>;

	general method
	{
		begin  -- all links null
		{
			io.linkage:begin;  
		}

		get_link ( int i )( link ) 
		{
			io.linkage:use_object( i ) ~nl;
			if ( "is_not_null?( ~nl )" ) given\link:begin( ~nl );
		}

		set_link [upd]( int i, link )
		{
			io.linkage:use_object( i ) <= given\link;
		}

		unlink [upd]( int i )
		{
			io.linkage:use_object( i ):reuse;
		}
	}


	instance
	{
		linkage;
	}
}


type <t>node<#> from ( <t>, node<<#>> )
{{
	A <t>node<#> is a generic synthetic node.

	<t> must be a complete type, or it can be an incomplete
	type if it doesn't have any [tbd] abstract methods
	(which forces the synthetic node to be incomplete).

	All methods are inherited from base types.  

	General :begin uses a co-routine to initialize
	application type <t>.

	Default :begin can be used if default <t>:begin
	is available.

	Synthetic nodes of the same dimension and related
	types can interlink.

	Usually, applications will turn some type <t> into
	a linkable type by defining a particular nom type
	for <t>.  For example
	
		nom type thing_node = <thing>node<'2'>.
}}
{
	general method
	{
		begin  -- default <t> initializer
		{
			io:base<node<<#>>>:begin;
			io:base<<t>>:begin;
		}

		begin with initializer ()( <t> )  
		{
			io:base< node<<#>> >:begin;
			initializer()( io:base<<t>> );
		}
	}
}



type node1 
{{
	A node1 is a specialized one-way node.

	A node1 is essentially an smp wrapped in node
	methodology.
}}
{
	nom type link = smp<node1>;

	general method
	{
		begin  -- null link
		{
		}

		get_link ()( link )
		{
			if ( "is_not_null?( io.link )" ) given\link:begin( io.link );
		}

		set_link [upd]( link )
		{
			io.link <= given\link;
		}

		unlink [upd]
		{
			io.link:reuse;
		}
	}

	instance
	{
		link [opt];
	}
}


type <t>node1 from ( <t>, node1 )
{{
	specialized synthetic node1
}}
{
	general method
	{
		begin -- default <t> initializer
		{
			io:base<node1>:begin;
			io:base<<t>>:begin;
		}

		begin with initializer ()( <t> )
		{
			io:base<node1>:begin;
			initializer()( io:base<<t>> );
		}
	}
}




