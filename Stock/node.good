
page node in StockByGood


{{
	On this page:
	
	node			variable-way base
	node<#>			generic fixed-way base 
	<t>node<#>		generic fixed-way synthetic node 

	node1			specialized one-way base
	<t>node1		specialized one-way synthetic node
}}



type node [incomplete]
{{
	A node is a multi-link adapatable base type.
	
	Nodes interconnect with other nodes using indexed links.

	A node can have any number of links and link allocation
	is dynamic.  
	
	This node type is used when a nexus interconnects in 
	diverse ways. 

	When node dimension is known and uniform, use a node<#>
	instead.
}}
{
	nom type link = <node>link;
	nom type linkage = <link>array;

	general method
	{
		begin ( int dim [opt] )
		{
			io.linkage:begin( dim );
		}

		get_link ( int i )( link nl )
		{
			nl:begin( io.linkage:use_object( i ) );
		}

		set_link [upd]( int i, link nl )
		{
			io:make_room( i );
			io.linkage:use_object( i ):reuse:begin( nl );
		}

		unlink [upd]( int i )
		{
			io.linkage:use_object( i ):reuse;
		}
	}

	misc method
	{
		make_room [upd]( int i )
		{
			io.linkage:count()( int q );
			i:sub( q )( =int ):add( one )( int need );
			if ( "need |>| zero" ) io.linkage:insert( q, need ); -- at i = q
		}
	}

	instance
	{
		linkage;
	}
}


type node<#> [incomplete]
{{
	A node<#> is a generic fixed dimension node.
	
	node<#> linkage is uniform.  That is, all nodes in a
	<#n>-way nexus are of the same dimension.

	A node<#> is technically complete, but doesn't have any
	practical application as an actual type. It should be 
	used as a base type for application	types.

	node<'1'> is valid, but specialized node1 is a better
	alternative.
}}
{
	nom type link = <node<<#>>>link;
	nom type linkage = <<#>>ply<link>;

	general method
	{
		begin  -- all links null
		{
			io.linkage:begin;  -- all links null
		}

		get_link ( int i )( link nl ) 
		{
			io.linkage:use_object( i ) ~nl;
			if ( "is_not_null?( ~nl )" ) nl:begin( ~nl );
		}

		set_link [upd](int i, <node<<#>>>link> nl )
		{
			io.linkage:use_object( i ):reuse:begin( nl );
		}

		unlink [upd]( int i )
		{
			io.linkage:use_object( i ):reuse;
		}
	}

	instance
	{
		linkage;
	}
}


type <t>node<#> from ( <t>, node<<#>> )
{{
	A <t>node<#> is a generic synthetic node.

	<t> must be a complete type, or it can be an incomplete
	type if it doesn't have any [tbd] abstract methods
	(which forces the synthetic node to be incomplete).

	All methods are inherited from base types.  

	General :begin uses a co-routine to initialize
	application type <t>.

	Default :begin can be used if default <t>:begin
	is available.

	Synthetic nodes of the same dimension and related
	types can interlink.

	Usually, applications will turn some type <t> into
	a linkable type by defining a particular nom type
	for <t>.  For example
	
		nom type thing_node = <thing>node<'2'>.
}}
{
	general method
	{
		begin
		{
			io:as_base< node<<#>> >:begin;
			io:as_base<<t>>:begin;
		}

		begin with co_begin ()( <t> )
		{
			io:as_base< node<<#>> >:begin;
			co_begin()( io:as_base<<t>> );
		}
	}
}



type node1 
{{
	A node1 is a specialized one-way node.
}}
{
	nom type link = <node1>link;

	general method
	{
		begin  -- null link
		{
		}

		get_link ()( link nl )
		{
			if ( "is_not_null?( io.link )" ) nl:begin( io.link );
		}

		set_link [upd]( link nl )
		{
			io.link:reuse:begin( nl );
		}

		unlink [upd]
		{
			io.link:reuse;
		}
	}

	instance
	{
		link;
	}
}




type <t>node1 from ( <t>, node1 )
{{
	specialized synthetic node1
}}
{
	general method
	{
		begin
		{
			io:as_base<node1>:begin;
			io:as_base<<t>>:begin;
		}

		begin with co_begin ()( <t> )
		{
			io:as_base<node1>:begin;
			co_begin()( io:as_base<<t>> );
		}
	}
}




