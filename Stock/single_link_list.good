
page single_link_list in stock@good

{{
	types on this page:

	list_cursor
	single_link_list
	lifo_list<nt>
	fifo_list<nt>

}}


type list_cursor
{{
	A list cursor is inoperable if io.nl is null.

	Note:  the cursor itself is not null.
}}
{
	general
	{
		begin ( <node1>link nl [opt] )
		{
			if ( "is_not_null?( nl )" ) io.nl:begin( nl );
		}

		move [upd]
		{
			if ( "is_not_null?( io.nl )" ) 
			{
				io.nl:use:get_link()( <node1>link next );
				io.nl:reuse;
				if ( "is_not_null?( next )" ) io.nl:begin( next );
			}
		}

		flip [upd]
		{
			io.nl:reuse;  -- not supported
		}

		use_node = node1 proxy ~n;
		{
			if ( "is_not_null?( io.nl )" ) ~n -> io.nl:use 
		}
	}

	instance
	{
		<node1>link nl [opt];
	}
}


type single_link_list from sequence<node1><list_cursor>
{{
	One-way linked list with heterogenous nodes.

	There are five named list positions: "front", "first",
	"last",	"current", and "next".  

	front is a nominal position before the first node.
	It always exists in principle.  The other positions
	designate nodes that may or may not exist.  If the 
	list has at least one node, first and last exist and
	are well-defined.  
	
	Generally, the next node follows the current position.
	If the last node is current, the next node doesn't 
	exist.  If the front position is current, next refers 
	to the first node.

	The current node can be set using :go methods. 

	:go_front makes the front position current.
	
	:go_first makes the first node current if it exists.

	:go_last makes the last node current if it exists.

	:go_next makes the next node current if it exists.

	:go_here makes a given node current.  The given node
	link must reference a node in the list.  Use :get_next
	or :get_current to get a valid link.

	NOTE! This method can really screw things up if the
	link doesn't reference a node in the list.

	:insert and :remove_next are the essential methods 
	used to build a list.  

	:insert adds a node link after the current position.
	The current position doesn't change.  The given node 
	should be a new (unlinked) node, but the method clears
	the link just in case.

	NOTE! It's possible to re-insert (move) a node in the
	list if it's removed before reinserting.  Failure to
	properly unlink a node that was previously linked in
	the same (or any other) list will make a real mess of
	things.

	:remove_next removes the next node from the list if it
	exists. It does this by linking the current node to 
	the node after the next node, if it exists.  current 
	position doesn't change.
	
	A constant list can be traversed using [eval] :get
	methods.  :get methods copy a named link if it exists.  
	Once a named link is copied, the list is traversed by
	calling 

		nl:use:get_link()( <node1>link next )

	until next is null.

	Typed methods are provided in a segregated group. Most
	of them work with a given coroutine allowing for generic
	subtypes that compile with any type provided a proper 
	coroutine can be given for the method and node type.

	Note: standard coroutines make calling these methods
	straight forward.
}}
{
	general method
	{
		begin  -- original empty
		{
			io:as_base<sequence<node1><<node1>link>:begin;
		}

		begin ( single_link_list other [upd] )  -- move 
		{
			if ( "is_not_null?( other.first )" )
			{
				-- ignore current in other
				io.first:begin( other.first );  
				io.last:begin( other.last );
				other.first:reuse;
				other.last:reuse;
				other.current:reuse;  -- go front
			}
		}

		is_empty? ()( bool yes )
		{
			io.first:is_null?()( yes );
		}

		go_front [upd]  -- before first
		{
			io.current:reuse;
		}

		go_first [upd]
		{
			if ( "is_not_null?( io.first )" ) io.current:reuse:begin( io.first );
		}

		go_last [upd]
		{
			if ( "is_not_null?( io.last )" ) io.current:reuse:begin( io.last );
		}

		go_next [upd]
		{
			if ( "is_null?( io.current )" )
			{
				if ( "is_not_null?( io.first )" ) io.current:reuse:begin( io.first );
			}
			else
			{
				io.current:use:get_link()( <node1>link nl ); 
				if ( "is_not_null?( nl )" ) io.current:reuse:begin( nl );
			}
		}

		go_here [upd]( <node1>link nl )  
		{
			io.current:reset:begin( nl );
		}
		
		
		get_first [eval]()( <node1>link nl )
		{
			if ( "is_not_null?( io.first )" ) nl:begin( io.first );
		}

		get_last [eval]()( <node1>link nl )
		{
			if ( "is_not_null?( io.last )" ) nl:begin( io.last );
		}

		get_current [eval]()( <node1>link nl )
		{
			if ( "is_not_null?( io.current )" ) nl:begin( io.current );
		}

		get_next [eval]()( <node1>link nl ) 
		{
			if ( "is_not_null?( io.current )" ) io.current:use:get_link()( nl );
		}


		insert [upd]( <node1>link nl )  -- after current  
		{
			nl:use:unlink;  -- just in case
			if ( "is_not_null?( io.current )" )  
			{
				-- after current
				io.current:use:get_link()( <node1>link before ):set_link( nl ); 
				if ( "is_null?( before )" )
					io.last:reuse:begin( nl )
				else
					nl:use:set_link( before );
			}
			else if ( "is_not_null?( io.first )" )
			{
				-- front (before first)
				nl:use:set_link( io.first );
				io.first:reuse:begin( nl );
			}
			else 
			{
				-- first and only node
				io.first:begin( nl );
				io.last:begin( nl );
			}
		}
	
		remove_next [upd]
		{
			if ( "is_not_null?( io.current )" ) 
			{
				-- node after current
				io.current:use:get_link()( <node1>link next );
				if ( "is_not_null?( next )" ) 
				{
					next:use:get_link()( <node1>link next_next ):unlink;
					if ( "is_null?( next_next )" )
						io.last:reuse:begin( io.current ) -- new last
					else 
						io.current:use:set_link( next_next );
				}
			}
			else if ( "is_not_null?( io.first )" ) 
			{
				-- first node
				io.first:use:get_link()( linked<node> next_next ):unlink;
				if ( "is_null?( next_next )" )
				{
					-- list is empty now
					io.first:reuse;
					io.last:reuse;
				}
				else
				{
					io.first:reuse:begin( next_next );  -- new first
				}
			}
		}
	}


	general method  -- typed node <nt> must derive from node1
	{
		insert<nt> [upd] with initiate ()( <nt> )  -- after current
		{
			initiate()( <<nt>>link nl:begin:use_actual );
			io:insert( nl as <node1>link );
		}
		
		copy_next<nt> ()( <nt> node ) with copy ( <nt> )( <nt> )
		{
			io:get_next()( <node1>link nl );
			if ( "is_not_null?( nl )" )	copy( nl:use:as<<nt>> )( node );
		}

		move_next<nt> [upd] ()( <t> node ) with move ( <nt> [upd] )( <nt> ) 
		{
			io:get_next()( <node1>link nl );
			if ( "is_not_null?( nl )" ) move( nl:use:as<<nt>> )( node );
		}

		use_current<nt> = <nt> proxy [upd] ~n   -- void possible
		{
			if ( "is_not_null?( io.current )" ) ~n -> io.current:use:as<<nt>>;
		}
	}


	abstract in sequence<node1><list_cursor>
	{
		[final] ~open_cursor ( int step )( list_cursor c )
		{	
			if ( "step |=| one" ) c:begin( io.first ) else c:begin;
		}  

		[final] ~move_cursor ( list_cursor c [upd] )
		{
			c:move;
		}

		[final] ~flip_cursor ( list_cursor c [upd] )
		{
			c:flip;
		}

		[final] ~use_object ( list_cursor c ) = node1 proxy ~node   
		{
			~node -> c:use_node;
		}
	}
	
	instance
	{
		<node1>link first   [opt];
		<node1>link last    [opt];
		<node1>link current [opt];  
	}

}



type lifo_list<nt> from single_link_list  -- typed stack
{{
	<nt> derived from node1

	push (insert) and pull (remove) list where front node is
	always current.

	NOTE!  Implementation assumes current node starts at
	front and doesn't change.  Application must restore
	current node if base methods are called. 

	pull with transfer requires a proper coroutine to select
	and reconcile call.

	my_stack:pull()( thing next ) with std_move<thing>;

	my_stack:pull()( thing next ) with std_copy<thing>;
}}
{
	general method
	{
		begin
		{
			io:as_base<single_link_list>:begin;
		}

		begin ( lifo_list<<nt>> other [upd] )  -- move 
		{
			io:as_base<single_link_list>:begin( *other );
		}

		push [upd] with initiate ()( <nt> node )
		{
			io:insert<<nt>> with initiate;  
		}

		pull [upd]()( <nt> node ) with copy ( <nt> )( <nt> )
		{
			io:copy_next()( node ) with copy;
			io:remove_next();
		}

		pull [upd]()( <nt> node ) with move ( <nt> [upd] )( <nt> )
		{
			io:move_next()( node ) with move;
			io:remove_next();
		}

		pull [upd] -- no transfer
		{
			io:remove_next;
		}
	}
}




type fifo_list<nt> from single_link_list  -- typed queue
{{
	<nt> derived from node1

	push (insert) last node and pull (remove) first node.

	pull with transfer requires a proper coroutine to select
	and reconcile call.
}}
{
	general method
	{
		begin
		{
			io:as_base<single_link_list>:begin;
		}

		begin ( fifo_list<<nt>> other [upd] )  -- move 
		{
			io:as_base<single_link_list>:begin( *other );
		}

		push [upd] with initiate ()( <nt> node )
		{
			io:go_last:insert with initiate;
		}

		pull [upd]()( <nt> node ) with copy ( <nt> )( <nt> )
		{
			io:go_front:copy_next()( node ) with copy;
			io:remove_next;
		}

		pull [upd]()( <nt> node ) with move ( <nt> [upd] )( <nt> )
		{
			io:go_front:move_next()( node ) with move;
			io:remove_next;
		}

		pull [upd]  -- no transfer
		{
			io:go_front:remove_next;
		}
	}
}




